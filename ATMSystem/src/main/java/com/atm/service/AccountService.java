package com.atm.service;

import com.atm.dto.AccountDTO;
import com.atm.model.Account;
import com.atm.model.Credential;
import com.atm.model.User;
import com.atm.repository.AccountRepository;
import com.atm.repository.BalanceRepository;
import com.atm.repository.CredentialRepository;
import com.atm.repository.UserRepository;
import com.atm.model.Balance;
import com.atm.util.JwtUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class AccountService {
    private static final Logger logger = LoggerFactory.getLogger(AccountService.class);

    private final AccountRepository accountRepository;
    private final CredentialRepository credentialRepository;
    private final BalanceRepository balanceRepository;
    private final UserRepository userRepository;
    private final JdbcTemplate jdbcTemplate;
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public AccountService(AccountRepository accountRepository,
                          CredentialRepository credentialRepository,
                          BalanceRepository balanceRepository,
                          UserRepository userRepository,
                          JdbcTemplate jdbcTemplate,
                          JwtUtil jwtUtil,
                          PasswordEncoder passwordEncoder) {
        this.accountRepository = accountRepository;
        this.credentialRepository = credentialRepository;
        this.balanceRepository = balanceRepository;
        this.userRepository = userRepository;
        this.jdbcTemplate = jdbcTemplate;
        this.jwtUtil = jwtUtil;
        this.passwordEncoder = passwordEncoder;
    }

    public Account getAccount(String accountNumber) {
        Optional<Account> accountOpt = accountRepository.findByAccountNumber(accountNumber);

        if (accountOpt.isPresent()) {
            Account account = accountOpt.get();
            logger.info("üîç T√†i kho·∫£n t√¨m th·∫•y: {}, Role: {}", account.getAccountNumber(), account.getRole());
            return account;
        }

        logger.warn("‚ö† Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n: {}", accountNumber);
        return null;
    }

    // ƒêƒÉng k√Ω t√†i kho·∫£n m·ªõi
    @Transactional
    public Account register(Account account) {
        logger.info("üîç ƒêang v√†o ph∆∞∆°ng th·ª©c register...");
        logger.info("Received request to register account: {}", account.getAccountNumber());

        // Ki·ªÉm tra xem t√†i kho·∫£n ƒë√£ t·ªìn t·∫°i hay ch∆∞a
        if (accountRepository.existsById(account.getAccountNumber())) {
            logger.error("Account already exists: {}", account.getAccountNumber());
            throw new IllegalArgumentException("T√†i kho·∫£n ƒë√£ t·ªìn t·∫°i!");
        }

        // Ki·ªÉm tra User c·ªßa t√†i kho·∫£n
        User user = account.getUser();
        if (user == null) {
            // N·∫øu kh√¥ng c√≥ th√¥ng tin ng∆∞·ªùi d√πng trong account, l·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ DB
            logger.info("User c·ªßa t√†i kho·∫£n l√† null, ki·ªÉm tra l·∫°i t·ª´ DB...");
            user = userRepository.findByUserId(account.getUser().getUserId()).orElse(null);

            if (user != null) {
                // Ki·ªÉm tra r√†ng bu·ªôc 1 userId ch·ªâ c√≥ 1 name
                if (!user.getName().equals(account.getFullName())) {
                    logger.error("User with ID {} already exists with a different name: {}", account.getUser().getUserId(), user.getName());
                    throw new IllegalArgumentException("T√™n ng∆∞·ªùi d√πng kh√¥ng kh·ªõp v·ªõi userId!");
                }
            }
        }

        if (user == null) {
            // N·∫øu kh√¥ng t√¨m th·∫•y User trong DB, t·∫°o User m·ªõi v√† g√°n cho t√†i kho·∫£n
            logger.info("Kh√¥ng t√¨m th·∫•y User, t·∫°o User m·ªõi...");

            // L·∫•y full name t·ª´ t√†i kho·∫£n
            String fullName = account.getFullName();  // T√™n ng∆∞·ªùi d√πng t·ª´ Account

            // L·∫•y userId ng∆∞·ªùi d√πng nh·∫≠p v√†o (n·∫øu c√≥)
            String userId = account.getUser().getUserId();  // Gi·∫£ s·ª≠ ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p userId khi t·∫°o account

            // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa userId (CCCD ph·∫£i l√† 12 s·ªë)
            if (userId == null || !userId.matches("\\d{12}")) {
                logger.error("Invalid userId: {}", userId);
                throw new IllegalArgumentException("userId ph·∫£i l√† 12 s·ªë (CCCD)");
            }

            // T·∫°o user m·ªõi t·ª´ userId v√† t√™n ng∆∞·ªùi d√πng
            user = new User();
            user.setUserId(userId);  // L∆∞u userId ng∆∞·ªùi d√πng nh·∫≠p v√†o
            user.setName(fullName);  // L∆∞u t√™n ng∆∞·ªùi d√πng nh·∫≠p v√†o (t∆∞∆°ng ·ª©ng v·ªõi full_name trong Account)

            // L∆∞u User m·ªõi v√†o DB
            userRepository.save(user);
            logger.info("User m·ªõi ƒë∆∞·ª£c t·∫°o v·ªõi ID: {}", user.getUserId());

            // G√°n User cho t√†i kho·∫£n
            account.setUser(user);
        } else {
            logger.info("User ƒë√£ t·ªìn t·∫°i: {}", user.getUserId());
        }

        // L∆∞u t√†i kho·∫£n v√†o b·∫£ng Account
        Account savedAccount = accountRepository.save(account);
        accountRepository.flush(); // ƒê·∫£m b·∫£o t√†i kho·∫£n ƒë∆∞·ª£c commit v√†o DB

        // T·∫°o v√† l∆∞u th√¥ng tin Balance
        Balance balance = new Balance();
        balance.setAccount(savedAccount); // Li√™n k·∫øt Balance v·ªõi t√†i kho·∫£n
        balance.setBalance(0.0); // S·ªë d∆∞ m·∫∑c ƒë·ªãnh
        balance.setLastUpdated(LocalDateTime.now());
        balanceRepository.save(balance);
        logger.info("Balance record created for account: {}", savedAccount.getAccountNumber());

        // T·∫°o th√¥ng tin Credential v·ªõi PIN m·∫∑c ƒë·ªãnh
        Credential credential = new Credential();
        credential.setAccount(savedAccount);
        credential.setPin(passwordEncoder.encode("000000")); // M√£ h√≥a PIN m·∫∑c ƒë·ªãnh
        credential.setFailedAttempts(0);
        credential.setLockTime(null);
        credential.setUpdateAt(LocalDateTime.now());
        credentialRepository.save(credential);

        logger.info("Successfully registered account: {}", savedAccount.getAccountNumber());
        return savedAccount;
    }

    // Ki·ªÉm tra user c√≥ t·ªìn t·∫°i kh√¥ng
    public boolean isUserExists(String userId) {
        String sql = "SELECT COUNT(*) FROM user WHERE user_id = ?";
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
        return count != null && count > 0;
    }

    // T·∫°o m·ªõi User n·∫øu ch∆∞a t·ªìn t·∫°i
    // Trong AccountService
    public void createUser(User user) {
        logger.info("Creating user with id: {}", user.getUserId());

        String sqlCheck = "SELECT user_id FROM `User` WHERE user_id = ?";
        String existingUserId = null;

        try {
            existingUserId = jdbcTemplate.queryForObject(sqlCheck, String.class, user.getUserId());
        } catch (EmptyResultDataAccessException e) {
            // N·∫øu kh√¥ng t√¨m th·∫•y, ti·∫øp t·ª•c t·∫°o m·ªõi
        }

        if (existingUserId != null) {
            logger.info("User already exists with ID: {}", existingUserId);
            return; // Ho·∫∑c b·∫°n c√≥ th·ªÉ n√©m ra ngo·∫°i l·ªá n·∫øu c·∫ßn
        } else {
            logger.info("User does not exist, creating user with id: {}", user.getUserId());

            // Ch√®n user m·ªõi v√†o c∆° s·ªü d·ªØ li·ªáu
            String sqlInsert = "INSERT INTO `User` (user_id, name) VALUES (?, ?)";
            int rows = jdbcTemplate.update(sqlInsert, user.getUserId(), user.getName());

            if (rows > 0) {
                logger.info("User created with ID: {}", user.getUserId());
            } else {
                logger.error("Failed to create user with id: {}", user.getUserId());
                throw new RuntimeException("Failed to create user");
            }
        }
    }

    @Transactional
    public void updateAccount(AccountDTO accountDTO, String accountNumber) {
        Optional<Account> optionalAccount = accountRepository.findById(accountDTO.getAccountNumber());

        if (optionalAccount.isPresent()) {
            Account account = optionalAccount.get();

            // Ki·ªÉm tra quy·ªÅn c·∫≠p nh·∫≠t
            String userRole = getUserRole(accountNumber);
            if (!"ADMIN".equals(userRole) && !accountNumber.equals(accountDTO.getAccountNumber())) {
                throw new RuntimeException("B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t t√†i kho·∫£n n√†y!");
            }

            // C·∫≠p nh·∫≠t th√¥ng tin Account n·∫øu c√≥ thay ƒë·ªïi
            if (accountDTO.getFullName() != null) {
                account.setFullName(accountDTO.getFullName());
            }

            // C·∫≠p nh·∫≠t Balance n·∫øu t·ªìn t·∫°i, ho·∫∑c t·∫°o m·ªõi
            if (accountDTO.getBalance() != null) {
                if (account.getBalanceEntity() == null) {
                    // T·∫°o m·ªõi Balance n·∫øu ch∆∞a c√≥
                    Balance newBalance = new Balance();
                    newBalance.setBalance(accountDTO.getBalance());  // S·ª≠ d·ª•ng balance thay v√¨ available_balance
                    newBalance.setAccount(account);  // Li√™n k·∫øt Balance v·ªõi Account
                    account.setBalanceEntity(newBalance);
                    balanceRepository.save(newBalance);  // L∆∞u Balance m·ªõi
                } else {
                    // C·∫≠p nh·∫≠t Balance n·∫øu ƒë√£ t·ªìn t·∫°i
                    account.getBalanceEntity().setBalance(accountDTO.getBalance());
                    balanceRepository.save(account.getBalanceEntity());  // L∆∞u Balance ƒë√£ c·∫≠p nh·∫≠t
                }
            }

            // C·∫≠p nh·∫≠t Pin n·∫øu c√≥ thay ƒë·ªïi
            if (accountDTO.getPin() != null) {
                Optional<Credential> optionalCredential = credentialRepository.findById(accountDTO.getAccountNumber());
                if (optionalCredential.isPresent()) {
                    Credential credential = optionalCredential.get();
                    credential.setPin(passwordEncoder.encode(accountDTO.getPin())); // M√£ h√≥a pin m·ªõi
                    credential.setUpdateAt(LocalDateTime.now());
                    credentialRepository.save(credential);  // L∆∞u Credential ƒë√£ c·∫≠p nh·∫≠t
                } else {
                    throw new RuntimeException("Kh√¥ng t√¨m th·∫•y th√¥ng tin Credential cho t√†i kho·∫£n n√†y.");
                }
            }

            // C·∫≠p nh·∫≠t Role n·∫øu c√≥ thay ƒë·ªïi
            if (accountDTO.getRole() != null && !accountDTO.getRole().isEmpty()) {
                account.setRole(accountDTO.getRole());
            }

            // C·∫≠p nh·∫≠t User n·∫øu c√≥ thay ƒë·ªïi
            if (account.getUser() != null) {
                User user = account.getUser();

                // C·∫≠p nh·∫≠t s·ªë ƒëi·ªán tho·∫°i trong User n·∫øu c√≥ thay ƒë·ªïi
                if (accountDTO.getPhoneNumber() != null && !accountDTO.getPhoneNumber().equals(user.getPhone())) {
                    user.setPhone(accountDTO.getPhoneNumber());
                }

                // C·∫≠p nh·∫≠t t√™n ƒë·∫ßy ƒë·ªß trong User n·∫øu c√≥ thay ƒë·ªïi
                if (accountDTO.getFullName() != null && !accountDTO.getFullName().equals(user.getName())) {
                    user.setName(accountDTO.getFullName());
                }

                // L∆∞u th√¥ng tin User ƒë√£ c·∫≠p nh·∫≠t
                try {
                    userRepository.save(user);  // L∆∞u th√¥ng tin User ƒë√£ c·∫≠p nh·∫≠t
                } catch (Exception e) {
                    throw new RuntimeException("C√≥ l·ªói khi l∆∞u th√¥ng tin ng∆∞·ªùi d√πng: " + e.getMessage());
                }
            } else {
                throw new RuntimeException("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng li√™n k·∫øt v·ªõi t√†i kho·∫£n n√†y.");
            }

            // L∆∞u Account (Hibernate s·∫Ω t·ª± ƒë·ªông l∆∞u Balance khi Account ƒë∆∞·ª£c l∆∞u)
            accountRepository.save(account);

        } else {
            throw new RuntimeException("T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i.");
        }
    }

    public Double getBalance(String accountNumber) {
        // L·∫•y t√†i kho·∫£n ƒëang ƒëƒÉng nh·∫≠p
        String loggedInAccountNumber = getLoggedInAccountNumber();

        // Ki·ªÉm tra xem t√†i kho·∫£n y√™u c·∫ßu c√≥ ph·∫£i c·ªßa ng∆∞·ªùi d√πng ƒëang ƒëƒÉng nh·∫≠p hay kh√¥ng
        if (!accountNumber.equals(loggedInAccountNumber)) {
            throw new SecurityException("B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p s·ªë d∆∞ c·ªßa t√†i kho·∫£n n√†y.");
        }

        return accountRepository.findByAccountNumber(accountNumber)
                .map(Account::getBalance)
                .orElseThrow(() -> new RuntimeException("T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i."));
    }

    // H√†m l·∫•y s·ªë t√†i kho·∫£n c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i
    public String getLoggedInAccountNumber() {
        System.out.println("üîç Ki·ªÉm tra SecurityContextHolder: " + SecurityContextHolder.getContext().getAuthentication());

        if (SecurityContextHolder.getContext().getAuthentication() == null) {
            System.out.println("‚ùå SecurityContextHolder is NULL!");
            return null;
        }

        return (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    }

    // L·∫•y t·∫•t c·∫£ kh√°ch h√†ng (d√†nh cho nh√¢n vi√™n ng√¢n h√†ng)
    public List<Account> getAllCustomers() {
        return accountRepository.findAll();
    }
    public String getUserRole(String accountNumber) {
        return accountRepository.findRoleByAccountNumber(accountNumber);
    }
}